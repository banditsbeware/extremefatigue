<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../static/style.css" type="text/css">
    <title></title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async 
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
      html { overflow-x: hidden; }
      a#back {
        margin-top: 3px;
        margin-left: -15px;
        color: #515151;
        font-size: 12px;
        text-decoration: none;
      }
      h3 { color: black; }
      p {
        width: 40ch;
        background-color: #f5f5ffee;
      }
      div#stickyp { position: absolute; }
      div#stickyp img { display: block; margin: 10px auto; width: 30ch; }
    </style>
  </head>
  <main>
    <a id='back' href='/sa.php'>&lt; back</a>
    <div id='stickyp' style='position: absolute'>
    <p>
      a problem for God. transitions in the laboratory. rotating cylinders and a turning point. David Ruelle's idea for turbulence. loops in phase space. mille-feuilles and sausage. an astronomer's mapping. <q>fireworks or galaxies</q>.
    </p><p>
      This is the description of the chapter <q>Strange Attractors</q> from James Glieck's <em>Chaos</em>. He describes a strange attractor which can be seen in the path generated by the following iterative equations:
\[\displaylines{
  x_{i+1} = y_i + 1 - 1.4x_i^2 \\
  y_{i+1} = 0.3x_i 
}\]
which I have drawn on this page (sorry if you're on mobile). It's called <em>iterative</em> because one point (x<sub>i</sub>, y<sub>i</sub>) is used to calculate the next point (x<sub>i+1</sub>, y<sub>i+1</sub>). The cursor position is used as the starting point. With the cursor in certain regions, the attractor seems to vanish, as the equations cause points in that region to shoot off the screen rapidly. You can <button onclick='togglePath()'>toggle lines</button> to show a path from point to point, still starting at your cursor - this makes it easier to see the <q>shooting off</q>, but harder to see the general shape of the attractor.
    </p><p>
      It isn't strictly the case that moving further from the origin causes the path to diverge. <button onclick='toggleFractal()'>color the plane</button> to see the general shape, with the black region representing starting points that converge to the attractor. The shape reminds me of the <a target='_blank' href='https://evangelion.fandom.com/wiki/Israfel'>seventh angel</a> ..
    </p>
    <img src='../static/media/attractor-space.png'/>
    <img src='../static/media/israfel.jpg'/>
    <p>
      <em>Both of You, Dance Like You Want to Win!</em> is my favorite Evangelion episode because of the <a target='_blank' href='https://www.youtube.com/watch?v=Pr9ExScjBno'>62 second choreographed fight</a>, which motivates two of the main characters to overcome their differences and learn to move in sync.
    </p><p>
      Anyway, attractors could be thought of as <q>order</q> arising from chaos. There is definitely a <em>pattern</em> that emerges, though it is far from obvious how one could predict the boomerang shape given the two equations above. It also kind of looks like a chunk of Saturn's rings.
    </p><p>
      Chaotic systems are often discovered when looking at <em>phase space</em> as opposed to analysing the direct relationships between variables. That is, if your system has two degrees of freedom, you can plot one along the x-axis and the other along the y-axis; then each point represents a <em>state</em> of the system and you have the system's phase space. One of the most famous examples of this is the <a target='_blank' href='https://en.wikipedia.org/wiki/Lorenz_system'>Lorenz attractor</a>, which exists in the three dimensional phase space of a simplified weather model and is the origin of the popular idea of the <a target='_blank' href='https://en.wikipedia.org/wiki/Butterfly_effect'>Butterfly Effect</a>.
    </p>
    </div>
    <canvas style='pointer-events:none; z-index:-1'></canvas>
  </main>
  <script>
    const canvas = document.querySelector('canvas');
    const c = canvas.getContext('2d'); 

    var dim = Math.min(innerWidth, innerHeight);
    console.log(dim);
    
    canvas.width = dim;
    canvas.height = dim;
    var canvasRect = canvas.getBoundingClientRect();

    const mouse = {
      x: innerWidth / 2,
      y: innerHeight / 2
    };

    addEventListener('mousemove', (event) => {
      mouse.x = event.clientX - canvasRect.left;
      mouse.y = event.clientY - canvasRect.top;
    });

    addEventListener('resize', () => {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
      try {
        init();
      } catch (ReferenceError) { }
    });

    const move = (x, y) => { c.moveTo(x + sw, y + sh); }
    const line = (x, y) => { c.lineTo(x + sw, y + sh); }

    var path = false;
    var nPoints = 1000;
    const togglePath = () => { 
      path = !path; 
      nPoints = nPoints == 1000 ? 10 : 1000;
    }

    var fractal = false;
    const toggleFractal = () => { 
      c.clearRect(0,0, canvas.width, canvas.height); 
      drawAxes();
      fractal = !fractal; 
    }

    var s = dim/4, sw = dim/2/s, sh = dim/2/s;
    

    function dot(x, y, colo='black') {
      c.fillStyle = colo;
      c.beginPath();
      c.arc(x, y, 1.5/s, 0, 2*Math.PI, false);
      c.fill();
      c.closePath();
    }

    c.scale(s, s);

    c.lineWidth = 1/s;

    var x0 = 0, y0 = 0;
    var xi, yi;
    
    function animate() {
      requestAnimationFrame(animate);

      let rx = rand(-sw, sw), ry = rand(-sh, sh);
      if (fractal) {
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
        colorPoint(rand(-sw, sw), rand(-sh, sh));
      } else {
        c.clearRect(0, 0, canvas.width, canvas.height);
        drawAxes();

        x0 = mouse.x/s - sw, y0 = mouse.y/s - sh;
        for (let i=0; i<nPoints; i++) {
          if (path) {
            c.beginPath();
            move(x0, y0);
          }

          xi = y0 + 1 - (1.4 * x0 * x0);
          yi = 0.3 * x0;

          if (path) {
            line(xi, yi);
            c.stroke();
          } else {
            dot(xi + sw, yi + sh);
          }
          x0 = xi;
          y0 = yi;
        }
      }
    }
    
    animate();

    function rand(a, b) { return a + (b - a) * Math.random(); }

    const randInt = (a, b) => Math.floor(a + (b - a) * Math.random());

    const hypot = (a, b) => Math.sqrt(a**2 + b**2);

    function colorPoint(x, y) {
      let color = 'black';
      let x0 = x, y0 = y;
      for (let i=0; i<10; i++) {
        xi = y0 + 1 - (1.4 * x0 * x0);
        yi = 0.3 * x0;
        if (Math.abs(xi) > sw || Math.abs(yi) > sh) {
          color = 'red';
          break;
        }
        x0 = xi;
        y0 = yi;
      }
      dot(x + sw, y + sh, color);
      
    }

    function drawAxes() {
      c.save()
      c.strokeStyle = "rgb(0, 0, 0, 0.2)"
      c.lineWidth = 1/s
      c.beginPath()
      c.moveTo(0, sh)
      c.lineTo(2*sw, sh)
      c.moveTo(sw, 0)
      c.lineTo(sw, 2*sh)
      c.closePath()
      c.stroke()
      c.restore()
    }

  </script>
</html>

